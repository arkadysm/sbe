{% macro render_encoding_fields(name, fields) -%}
{%    for f in fields if f.type.presence != "constant" %}
{%       if f.type.type == "simple" %}
void {{name}}_set_{{f.name}}({{name}}_encoder_t* e, {{f.type|c_type_decl}} val);

{%          if f.type.presence == "optional" %}
void {{name}}_reset_{{f.name}}({{name}}_encoder_t* e);

{%          endif %}
{%       elif f.type.type == "enum" %}
int32_t {{name}}_set_{{f.name}}({{name}}_encoder_t* e, {{package}}_{{f.type.name}}_t val);

{%          if f.type.presence == "optional" %}
void {{name}}_reset_{{f.name}}({{name}}_encoder_t* e);

{%          endif %}
{%       elif f.type.type == "group" %}
{{name}}_{{f.name}}_encoder_t* {{name}}_add_{{f.name}}({{name}}_encoder_t* e, uint16_t num);

{{name}}_{{f.name}}_encoder_t* {{name}}_{{f.name}}_encode_next({{name}}_{{f.name}}_encoder_t* e);

uint16_t {{name}}_{{f.name}}_encode_get_idx({{name}}_{{f.name}}_encoder_t* e);

{{             render_encoding_fields(name+"_"+f.name, f.fields) -}}
{%       endif %}
{%    endfor %}
{% endmacro -%}

{% macro typedef_group_encoders(prefix, fields) %}
{%     for f in fields if f.type.type == "group" %}
typedef struct {{package}}_group_encoder_t {{prefix}}_{{f.name}}_encoder_t;

{{           typedef_group_encoders(prefix+"_"+f.name, f.fields)-}}
{%     endfor %}
{% endmacro -%}

/**
  * @brief CAUTION: do not change this file - it is autogenerated.
  */

#pragma once

#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#ifdef __cplusplus
extern "C"
{
#endif

typedef enum
{
   {{package}}_log_level_error  = 1,
   {{package}}_log_level_warn   = 2,
   {{package}}_log_level_notice = 4,
   {{package}}_log_level_info   = 8,
   {{package}}_log_level_debug  = 16,
   {{package}}_log_level_trace  = 32
} {{package}}_log_level_t;


typedef enum
{
{% for m in messages %}
   {{package}}_template_{{m.name}} = {{m.id}},
{% endfor %}
} {{package}}_templates_t;

{% for t in types if t.type == "enum" %}
{%    if t.description %}
// {{t.description}}
{%    endif %}
typedef enum
{
{%    for e in t.entries %}
   {{package}}_{{t.name}}_{{e.name}} = {%if t.encoding_type == "char"%}'{{e.value}}'{% else %}{{e.value}}{% endif %},{%if e.description%} // {%endif%}{{e.description}}
{%    endfor %}
} {{package}}_{{t.name}}_t;

{% endfor -%}


// encoding types

{% for m in messages %}
{%     if m|has_groups %}
struct {{package}}_{{m.name}}_encoder_t;

typedef struct {{package}}_{{m.name}}_encoder_t {{package}}_{{m.name}}_encoder_t;

{%     else %}
typedef struct {{package}}_default_encoder_s {{package}}_{{m.name}}_encoder_t;

{%     endif %}
{% endfor -%}

struct {{package}}_group_encoder_t;

{% for m in messages %}
{{-typedef_group_encoders(package+"_"+m.name, m.fields)-}}
{% endfor -%}


// encoder

void* {{package}}_encoder_create({{package}}_templates_t id, char* data, size_t len);

void {{package}}_encoder_destroy(void* encoder);


{% for m in messages %}
// {{m.name}} encoder

size_t {{package}}_{{m.name}}_encoder_get_var_offset({{package}}_{{m.name}}_encoder_t* e);

{{ render_encoding_fields(package+"_"+m.name, m.fields) -}}
{% endfor %}

#ifdef __cplusplus
}
#endif
