{# 
//--------------------------------------------------------------------------------------------------------------------//
Encoder macros
//--------------------------------------------------------------------------------------------------------------------//
#}

{% macro render_encoding_fields(name, fields) -%}
{%    for f in fields if f.type.presence != "constant" %}
{%       if f.type.type == "simple" %}
void {{name}}_set_{{f.name}}({{name}}_encoder_t* e, {{f.type|c_type_decl}} val);

{%          if f.type.presence == "optional" %}
void {{name}}_reset_{{f.name}}({{name}}_encoder_t* e);

{%          endif %}
{%       elif f.type.type == "enum" %}
int32_t {{name}}_set_{{f.name}}({{name}}_encoder_t* e, {{package}}_{{f.type.name}}_t val);

{%          if f.type.presence == "optional" %}
void {{name}}_reset_{{f.name}}({{name}}_encoder_t* e);

{%          endif %}
{%       elif f.type.type == "group" %}
{{name}}_{{f.name}}_encoder_t* {{name}}_add_{{f.name}}({{name}}_encoder_t* e, uint16_t num);

{{name}}_{{f.name}}_encoder_t* {{name}}_{{f.name}}_encode_next({{name}}_{{f.name}}_encoder_t* e);

uint16_t {{name}}_{{f.name}}_encode_get_idx({{name}}_{{f.name}}_encoder_t* e);

{{             render_encoding_fields(name+"_"+f.name, f.fields) -}}
{%       elif f.type.type == "data" %}
void {{name}}_set_{{f.name}}({{name}}_encoder_t* e, const {{f.dimension_type.data_type|c_type_decl}}* val, size_t len);

{%       endif %}
{%    endfor %}
{% endmacro -%}

{% macro typedef_group_encoders(prefix, fields) %}
{%     for f in fields if f.type.type == "group" %}
typedef struct {{package}}_group_encoder_t {{prefix}}_{{f.name}}_encoder_t;

{{           typedef_group_encoders(prefix+"_"+f.name, f.fields)-}}
{%     endfor %}
{% endmacro -%}

{# 
//--------------------------------------------------------------------------------------------------------------------//
Decoder macros
//--------------------------------------------------------------------------------------------------------------------//
#}

{% macro typedef_group_decoders(prefix, fields) %}
{%     for f in fields if f.type.type == "group" %}
typedef struct {{package}}_group_decoder_t {{prefix}}_{{f.name}}_decoder_t;

{{           typedef_group_decoders(prefix+"_"+f.name, f.fields)-}}
{%     endfor %}
{% endmacro -%}


{% macro render_decoding_fields(name, fields) -%}
{%    for f in fields %}
{%        if f.type.type == "simple" %}
{{f.type|c_type_decl}} {{name}}_get_{{f.name}}({{name}}_decoder_t* d);

{%            if f.type.presence == "optional" %}
bool {{name}}_{{f.name}}_is_null({{name}}_decoder_t* d);

{%            endif %}
{%        elif f.type.type == "enum" %}
{{package}}_{{f.type.name}}_t {{name}}_get_{{f.name}}({{name}}_decoder_t* d);

{%        elif f.type.type == "builtin" %}
{{f.type|c_type_decl}} {{name}}_get_{{f.name}}({{name}}_decoder_t* d);

{%        elif f.type.type == "composite" %}
{%            for t in f.type.types %}
{{t|c_type_decl}} {{name}}_get_{{f.name}}_{{t.name}}({{name}}_decoder_t* d);

{%            endfor %}
{%        elif f.type.type == "group" %}
{{name}}_{{f.name}}_decoder_t* {{name}}_get_{{f.name}}({{name}}_decoder_t* d);

{{name}}_{{f.name}}_decoder_t* {{name}}_{{f.name}}_decode_next({{name}}_{{f.name}}_decoder_t* d);

uint16_t {{name}}_{{f.name}}_decode_get_idx({{name}}_{{f.name}}_decoder_t* d);

size_t {{name}}_{{f.name}}_decode_get_count({{name}}_{{f.name}}_decoder_t* d);

{{             render_decoding_fields(name+"_"+f.name, f.fields) -}}
{%        elif f.type.type == "data" %}
size_t {{name}}_{{f.name}}_get_{{f.dimension_type.length_type.name}}({{name}}_decoder_t* d);

vardata_t {{name}}_{{f.name}}_get_vardata({{name}}_decoder_t* d);

{{f.dimension_type.data_type|c_type_decl}}* {{name}}_{{f.name}}_get_{{f.dimension_type.data_type.name}}({{name}}_decoder_t* d);

{%        endif %}
{%    endfor %}
{% endmacro -%}

{#
//--------------------------------------------------------------------------------------------------------------------//
Generated file
//--------------------------------------------------------------------------------------------------------------------//
#}

/**
  * @brief CAUTION: do not change this file - it is autogenerated.
  */

#pragma once

#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#ifdef __cplusplus
extern "C"
{
#endif

typedef enum
{
   {{package}}_log_level_error  = 1,
   {{package}}_log_level_warn   = 2,
   {{package}}_log_level_notice = 4,
   {{package}}_log_level_info   = 8,
   {{package}}_log_level_debug  = 16,
   {{package}}_log_level_trace  = 32
} {{package}}_log_level_t;


typedef enum
{
{% for m in messages %}
   {{package}}_template_{{m.name}} = {{m.id}},
{% endfor %}
} {{package}}_templates_t;

{% for t in types if t.type == "enum" %}
{%    if t.description %}
// {{t.description}}
{%    endif %}
typedef enum
{
{%    for e in t.entries %}
   {{package}}_{{t.name}}_{{e.name}} = {%if t.encoding_type == "char"%}'{{e.value}}'{% else %}{{e.value}}{% endif %},{%if e.description%} // {%endif%}{{e.description}}
{%    endfor %}
} {{package}}_{{t.name}}_t;

{% endfor -%}

typedef struct vardata_t
{
  size_t len;
  char* data;
} vardata_t;

//--------------------------------------------------------------------------------------------------------------------//
// encoding types

{% for m in messages %}
{%     if m|has_groups %}
struct {{package}}_{{m.name}}_encoder_t;

typedef struct {{package}}_{{m.name}}_encoder_t {{package}}_{{m.name}}_encoder_t;

{%     else %}
typedef struct {{package}}_default_encoder_s {{package}}_{{m.name}}_encoder_t;

{%     endif %}
{% endfor -%}

struct {{package}}_group_encoder_t;

{% for m in messages %}
{{-typedef_group_encoders(package+"_"+m.name, m.fields)-}}
{% endfor -%}

// encoder

void* {{package}}_encoder_create({{package}}_templates_t id, char* data, size_t len);

void {{package}}_encoder_destroy(void* encoder);

{% for m in messages %}
// {{m.name}} encoder

size_t {{package}}_{{m.name}}_encoder_get_var_offset({{package}}_{{m.name}}_encoder_t* e);

{{ render_encoding_fields(package+"_"+m.name, m.fields) -}}
{% endfor %}

//--------------------------------------------------------------------------------------------------------------------//
// decoding types

{% for m in messages %}
{%     if m|has_groups %}
struct {{package}}_{{m.name}}_decoder_t;

typedef struct {{package}}_{{m.name}}_decoder_t {{package}}_{{m.name}}_decoder_t;

{%     else %}
typedef struct {{package}}_default_decoder_s {{package}}_{{m.name}}_decoder_t;

{%     endif %}
{% endfor -%}

struct {{package}}_group_decoder_t;

{% for m in messages %}
{{-typedef_group_decoders(package+"_"+m.name, m.fields)-}}
{% endfor -%}

// decoder

void* {{package}}_decoder_create(char* data, size_t len);

void {{package}}_decoder_destroy(void* decoder);

{% for m in messages %}
// {{m.name}} decoder

size_t {{package}}_{{m.name}}_decoder_get_var_offset({{package}}_{{m.name}}_decoder_t* d);

{{-render_decoding_fields(package+"_"+m.name, m.fields)-}}
{% endfor %}

#ifdef __cplusplus
}
#endif
