{% macro typedef_group_decoders(prefix, fields) %}
{%     for f in fields if f.type.type == "group" %}
typedef struct {{package}}_group_decoder_t {{prefix}}_{{f.name}}_decoder_t;

{{           typedef_group_decoders(prefix+"_"+f.name, f.fields)-}}
{%     endfor %}
{% endmacro -%}

{% macro render_decoding_fields(name, fields) -%}
{%    for f in fields %}
{%        if f.type.type == "simple" %}
{{f.type|c_type_decl}} {{name}}_get_{{f.name}}({{name}}_decoder_t* d);

{%            if f.type.presence == "optional" %}
bool {{name}}_{{f.name}}_is_null({{name}}_decoder_t* d);

{%            endif %}
{%        elif f.type.type == "enum" %}
{{package}}_{{f.type.name}}_t {{name}}_get_{{f.name}}({{name}}_decoder_t* d);

{%        elif f.type.type == "builtin" %}
{{f.type|c_type_decl}} {{name}}_get_{{f.name}}({{name}}_decoder_t* d);

{%        elif f.type.type == "composite" %}
{%            for t in f.type.types %}
{{t|c_type_decl}} {{name}}_get_{{f.name}}_{{t.name}}({{name}}_decoder_t* d);

{%            endfor %}
{%        elif f.type.type == "group" %}
{{name}}_{{f.name}}_decoder_t* {{name}}_get_{{f.name}}({{name}}_decoder_t* d);

{{name}}_{{f.name}}_decoder_t* {{name}}_{{f.name}}_decode_next({{name}}_{{f.name}}_decoder_t* d);

uint16_t {{name}}_{{f.name}}_decode_get_idx({{name}}_{{f.name}}_decoder_t* d);

size_t {{name}}_{{f.name}}_decode_get_count({{name}}_{{f.name}}_decoder_t* d);

{{             render_decoding_fields(name+"_"+f.name, f.fields) -}}
{%        endif %}
{%    endfor %}
{% endmacro -%}

/**
  * @brief CAUTION: do not change this file - it is autogenerated.
  */

#pragma once

#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#ifdef __cplusplus
extern "C"
{
#endif

typedef enum
{
   {{package}}_log_level_error  = 1,
   {{package}}_log_level_warn   = 2,
   {{package}}_log_level_notice = 4,
   {{package}}_log_level_info   = 8,
   {{package}}_log_level_debug  = 16,
   {{package}}_log_level_trace  = 32
} {{package}}_log_level_t;


typedef enum
{
{% for m in messages %}
   {{package}}_template_{{m.name}} = {{m.id}},
{% endfor %}
} {{package}}_templates_t;

{% for t in types if t.type == "enum" %}
{%    if t.description %}
// {{t.description}}
{%    endif %}
typedef enum
{
{%    for e in t.entries %}
   {{package}}_{{t.name}}_{{e.name}} = {%if t.encoding_type == "char"%}'{{e.value}}'{% else %}{{e.value}}{% endif %},{%if e.description%} // {%endif%}{{e.description}}
{%    endfor %}
} {{package}}_{{t.name}}_t;

{% endfor -%}


// decoder

{% for m in messages %}
{%     if m|has_groups %}
struct {{package}}_{{m.name}}_decoder_t;

typedef struct {{package}}_{{m.name}}_decoder_t {{package}}_{{m.name}}_decoder_t;

{%     else %}
typedef struct {{package}}_default_decoder_s {{package}}_{{m.name}}_decoder_t;

{%     endif %}
{% endfor -%}

struct {{package}}_group_decoder_t;

{% for m in messages %}
{{-typedef_group_decoders(package+"_"+m.name, m.fields)-}}
{% endfor -%}

void* {{package}}_decoder_create(char* data, size_t len);

void {{package}}_decoder_destroy(void* decoder);

{% for m in messages %}
// {{m.name}} decoder

size_t {{package}}_{{m.name}}_decoder_get_var_offset({{package}}_{{m.name}}_decoder_t* d);

{{-render_decoding_fields(package+"_"+m.name, m.fields)-}}
{% endfor %}

#ifdef __cplusplus
}
#endif
