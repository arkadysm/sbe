/**
  * @brief CAUTION: do not change this file - it is autogenerated.
  */

#include "proto_encoder_priv.h"
#include <common/xroad_aux.h>
#include <math.h>



//--------------------------------------------------------------------------------------------------------------------//
void* proto_create_encoder(proto_templates_t tid, char* data, size_t len, proto_logger_cback_t cback)
{
   switch(tid)
   {
      case proto_template_InstrRequest:
      {
         if (len < sizeof(message_header_t) + 40)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_InstrRequest_encoder_t* encoder = calloc(1, sizeof(proto_InstrRequest_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 40;
         return encoder;
      }
      case proto_template_RequestFailed:
      {
         if (len < sizeof(message_header_t) + 4)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_RequestFailed_encoder_t* encoder = calloc(1, sizeof(proto_RequestFailed_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 4;
         return encoder;
      }
      case proto_template_RequestSucceed:
      {
         if (len < sizeof(message_header_t) + 4)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_RequestSucceed_encoder_t* encoder = calloc(1, sizeof(proto_RequestSucceed_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 4;
         return encoder;
      }
      case proto_template_InstrSetCQGNameRequest:
      {
         if (len < sizeof(message_header_t) + 68)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_InstrSetCQGNameRequest_encoder_t* encoder = calloc(1, sizeof(proto_InstrSetCQGNameRequest_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 68;
         return encoder;
      }
      case proto_template_InstrListRequest:
      {
         if (len < sizeof(message_header_t) + 5)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_InstrListRequest_encoder_t* encoder = calloc(1, sizeof(proto_InstrListRequest_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 5;
         return encoder;
      }
      case proto_template_InstrumentDefinition:
      {
         if (len < sizeof(message_header_t) + 131)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_InstrumentDefinition_encoder_t* encoder = calloc(1, sizeof(proto_InstrumentDefinition_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 131;
         InstrumentDefinition_t* msg = (InstrumentDefinition_t*)(encoder->base.data + sizeof(message_header_t));
         msg->strike = 0;
         return encoder;
      }
      case proto_template_MdSubscribe:
      {
         if (len < sizeof(message_header_t) + 47)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_MdSubscribe_encoder_t* encoder = calloc(1, sizeof(proto_MdSubscribe_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 47;
         return encoder;
      }
      case proto_template_MdUnsubscribe:
      {
         if (len < sizeof(message_header_t) + 45)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_MdUnsubscribe_encoder_t* encoder = calloc(1, sizeof(proto_MdUnsubscribe_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 45;
         return encoder;
      }
      case proto_template_MdSubscriptionResult:
      {
         if (len < sizeof(message_header_t) + 15)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_MdSubscriptionResult_encoder_t* encoder = calloc(1, sizeof(proto_MdSubscriptionResult_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 15;
         return encoder;
      }
      case proto_template_MdTrade:
      {
         if (len < sizeof(message_header_t) + 41)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_MdTrade_encoder_t* encoder = calloc(1, sizeof(proto_MdTrade_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 41;
         return encoder;
      }
      case proto_template_MdQuote:
      {
         if (len < sizeof(message_header_t) + 56)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_MdQuote_encoder_t* encoder = calloc(1, sizeof(proto_MdQuote_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 56;
         return encoder;
      }
      case proto_template_MdBook:
      {
         if (len < sizeof(message_header_t) + 8)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_MdBook_encoder_t* encoder = calloc(1, sizeof(proto_MdBook_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 8;
         return encoder;
      }
      case proto_template_MdStatistic:
      {
         if (len < sizeof(message_header_t) + 33)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_MdStatistic_encoder_t* encoder = calloc(1, sizeof(proto_MdStatistic_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 33;
         return encoder;
      }
      case proto_template_AccPosSubscribe:
      {
         if (len < sizeof(message_header_t) + 5)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_AccPosSubscribe_encoder_t* encoder = calloc(1, sizeof(proto_AccPosSubscribe_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 5;
         return encoder;
      }
      case proto_template_AccPosUnsubscribe:
      {
         if (len < sizeof(message_header_t) + 4)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_AccPosUnsubscribe_encoder_t* encoder = calloc(1, sizeof(proto_AccPosUnsubscribe_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 4;
         return encoder;
      }
      case proto_template_AccPosSubscriptionResult:
      {
         if (len < sizeof(message_header_t) + 5)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_AccPosSubscriptionResult_encoder_t* encoder = calloc(1, sizeof(proto_AccPosSubscriptionResult_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 5;
         return encoder;
      }
      case proto_template_AccBalanceSubscribe:
      {
         if (len < sizeof(message_header_t) + 5)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_AccBalanceSubscribe_encoder_t* encoder = calloc(1, sizeof(proto_AccBalanceSubscribe_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 5;
         return encoder;
      }
      case proto_template_AccBalanceUnsubscribe:
      {
         if (len < sizeof(message_header_t) + 4)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_AccBalanceUnsubscribe_encoder_t* encoder = calloc(1, sizeof(proto_AccBalanceUnsubscribe_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 4;
         return encoder;
      }
      case proto_template_AccBalanceSubscriptionResult:
      {
         if (len < sizeof(message_header_t) + 5)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_AccBalanceSubscriptionResult_encoder_t* encoder = calloc(1, sizeof(proto_AccBalanceSubscriptionResult_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 5;
         return encoder;
      }
      case proto_template_AccPosition:
      {
         if (len < sizeof(message_header_t) + 0)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_AccPosition_encoder_t* encoder = calloc(1, sizeof(proto_AccPosition_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 0;
         return encoder;
      }
      case proto_template_AccBalance:
      {
         if (len < sizeof(message_header_t) + 0)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_AccBalance_encoder_t* encoder = calloc(1, sizeof(proto_AccBalance_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 0;
         return encoder;
      }
      case proto_template_NewOrderSingle:
      {
         if (len < sizeof(message_header_t) + 119)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_NewOrderSingle_encoder_t* encoder = calloc(1, sizeof(proto_NewOrderSingle_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 119;
         NewOrderSingle_t* msg = (NewOrderSingle_t*)(encoder->base.data + sizeof(message_header_t));
         msg->algo_start = 4294967295;
         msg->algo_stop = 4294967295;
         msg->algo_aggr_level = 255;
         msg->algo_mid_time = 255;
         msg->algo_aggr_time = 255;
         msg->algo_price_move = -1;
         msg->algo_working_int = 4294967295;
         msg->algo_book_depth = 4294967295;
         msg->algo_level_dist = 4294967295;
         msg->algo_sensitivity = 4294967295;
         msg->algo_deviation = 4294967295;
         return encoder;
      }
      case proto_template_OrderAccepted:
      {
         if (len < sizeof(message_header_t) + 24)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_OrderAccepted_encoder_t* encoder = calloc(1, sizeof(proto_OrderAccepted_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 24;
         OrderAccepted_t* msg = (OrderAccepted_t*)(encoder->base.data + sizeof(message_header_t));
         msg->exch_id = 18446744073709551615;
         return encoder;
      }
      case proto_template_OrderRejected:
      {
         if (len < sizeof(message_header_t) + 21)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_OrderRejected_encoder_t* encoder = calloc(1, sizeof(proto_OrderRejected_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 21;
         return encoder;
      }
      case proto_template_CancelOrder:
      {
         if (len < sizeof(message_header_t) + 8)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_CancelOrder_encoder_t* encoder = calloc(1, sizeof(proto_CancelOrder_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 8;
         return encoder;
      }
      case proto_template_CancelOrderRejected:
      {
         if (len < sizeof(message_header_t) + 21)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_CancelOrderRejected_encoder_t* encoder = calloc(1, sizeof(proto_CancelOrderRejected_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 21;
         return encoder;
      }
      case proto_template_OrderCanceled:
      {
         if (len < sizeof(message_header_t) + 16)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_OrderCanceled_encoder_t* encoder = calloc(1, sizeof(proto_OrderCanceled_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 16;
         return encoder;
      }
      case proto_template_ReplaceOrder:
      {
         if (len < sizeof(message_header_t) + 75)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_ReplaceOrder_encoder_t* encoder = calloc(1, sizeof(proto_ReplaceOrder_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 75;
         ReplaceOrder_t* msg = (ReplaceOrder_t*)(encoder->base.data + sizeof(message_header_t));
         msg->algo_start = 4294967295;
         msg->algo_stop = 4294967295;
         msg->algo_aggr_level = 255;
         msg->algo_mid_time = 255;
         msg->algo_aggr_time = 255;
         msg->algo_price_move = -1;
         msg->algo_working_int = 4294967295;
         msg->algo_book_depth = 4294967295;
         msg->algo_level_dist = 4294967295;
         msg->algo_sensitivity = 4294967295;
         msg->algo_deviation = 4294967295;
         return encoder;
      }
      case proto_template_ReplaceOrderRejected:
      {
         if (len < sizeof(message_header_t) + 21)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_ReplaceOrderRejected_encoder_t* encoder = calloc(1, sizeof(proto_ReplaceOrderRejected_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 21;
         return encoder;
      }
      case proto_template_OrderReplaced:
      {
         if (len < sizeof(message_header_t) + 32)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_OrderReplaced_encoder_t* encoder = calloc(1, sizeof(proto_OrderReplaced_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 32;
         return encoder;
      }
      case proto_template_Trade:
      {
         if (len < sizeof(message_header_t) + 56)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_Trade_encoder_t* encoder = calloc(1, sizeof(proto_Trade_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 56;
         Trade_t* msg = (Trade_t*)(encoder->base.data + sizeof(message_header_t));
         msg->exch_id = 18446744073709551615;
         return encoder;
      }
      case proto_template_OrderExpired:
      {
         if (len < sizeof(message_header_t) + 16)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_OrderExpired_encoder_t* encoder = calloc(1, sizeof(proto_OrderExpired_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 16;
         return encoder;
      }
      case proto_template_TrdCaptReport:
      {
         if (len < sizeof(message_header_t) + 113)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_TrdCaptReport_encoder_t* encoder = calloc(1, sizeof(proto_TrdCaptReport_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 113;
         TrdCaptReport_t* msg = (TrdCaptReport_t*)(encoder->base.data + sizeof(message_header_t));
         msg->orderno = 18446744073709551615;
         return encoder;
      }
      case proto_template_Ping:
      {
         if (len < sizeof(message_header_t) + 12)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_Ping_encoder_t* encoder = calloc(1, sizeof(proto_Ping_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 12;
         return encoder;
      }
      case proto_template_Pong:
      {
         if (len < sizeof(message_header_t) + 12)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_Pong_encoder_t* encoder = calloc(1, sizeof(proto_Pong_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 12;
         return encoder;
      }
      case proto_template_SystemState:
      {
         if (len < sizeof(message_header_t) + 9)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_SystemState_encoder_t* encoder = calloc(1, sizeof(proto_SystemState_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 9;
         return encoder;
      }
      case proto_template_Heartbeat:
      {
         if (len < sizeof(message_header_t) + 8)
         {
            if (cback)
            {
               cback(proto_log_level_error, "buffer is too small");
            }
            return NULL;
         }
         proto_Heartbeat_encoder_t* encoder = calloc(1, sizeof(proto_Heartbeat_encoder_t));
         encoder->base.data = data;
         encoder->base.len = len;
         encoder->base.tid = tid;
         encoder->base.cback = cback;
         message_header_t* hdr = (message_header_t*)encoder->base.data;
         hdr->template_id = tid;
         hdr->schema_id = 1;
         hdr->version = 1;
         hdr->block_length = 8;
         return encoder;
      }
      default:
      {
         if (cback)
         {
            cback(proto_log_level_error, "unknown template id");
         }
         return NULL;
      }
   }
}

//--------------------------------------------------------------------------------------------------------------------//
void proto_destroy_encoder(void* encoder)
{
   free(encoder);
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_InstrRequest_get_size(proto_InstrRequest_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_RequestFailed_get_size(proto_RequestFailed_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_RequestSucceed_get_size(proto_RequestSucceed_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_InstrSetCQGNameRequest_get_size(proto_InstrSetCQGNameRequest_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_InstrListRequest_get_size(proto_InstrListRequest_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_InstrumentDefinition_get_size(proto_InstrumentDefinition_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_MdSubscribe_get_size(proto_MdSubscribe_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_MdUnsubscribe_get_size(proto_MdUnsubscribe_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_MdSubscriptionResult_get_size(proto_MdSubscriptionResult_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_MdTrade_get_size(proto_MdTrade_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_MdQuote_get_size(proto_MdQuote_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_MdBook_get_size(proto_MdBook_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_MdStatistic_get_size(proto_MdStatistic_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_AccPosSubscribe_get_size(proto_AccPosSubscribe_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_AccPosUnsubscribe_get_size(proto_AccPosUnsubscribe_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_AccPosSubscriptionResult_get_size(proto_AccPosSubscriptionResult_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_AccBalanceSubscribe_get_size(proto_AccBalanceSubscribe_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_AccBalanceUnsubscribe_get_size(proto_AccBalanceUnsubscribe_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_AccBalanceSubscriptionResult_get_size(proto_AccBalanceSubscriptionResult_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_AccPosition_get_size(proto_AccPosition_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_AccBalance_get_size(proto_AccBalance_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_NewOrderSingle_get_size(proto_NewOrderSingle_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_OrderAccepted_get_size(proto_OrderAccepted_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_OrderRejected_get_size(proto_OrderRejected_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_CancelOrder_get_size(proto_CancelOrder_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_CancelOrderRejected_get_size(proto_CancelOrderRejected_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_OrderCanceled_get_size(proto_OrderCanceled_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_ReplaceOrder_get_size(proto_ReplaceOrder_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_ReplaceOrderRejected_get_size(proto_ReplaceOrderRejected_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_OrderReplaced_get_size(proto_OrderReplaced_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_Trade_get_size(proto_Trade_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_OrderExpired_get_size(proto_OrderExpired_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_TrdCaptReport_get_size(proto_TrdCaptReport_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_Ping_get_size(proto_Ping_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_Pong_get_size(proto_Pong_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_SystemState_get_size(proto_SystemState_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

//--------------------------------------------------------------------------------------------------------------------//
int32_t proto_Heartbeat_get_size(proto_Heartbeat_encoder_t* encoder)
{
   encoder_t* e = (encoder_t*)encoder;
   message_header_t* hdr = (message_header_t*)e->data;
   return sizeof(message_header_t) + hdr->block_length + e->var_offset;
}

